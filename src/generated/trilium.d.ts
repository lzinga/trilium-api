/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/create-note": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Create a note and place it into the note tree */
        post: operations["createNote"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Search notes */
        get: operations["searchNotes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notes/{noteId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                noteId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        /** @description Returns a note identified by its ID */
        get: operations["getNoteById"];
        put?: never;
        post?: never;
        /** @description deletes a single note based on the noteId supplied */
        delete: operations["deleteNoteById"];
        options?: never;
        head?: never;
        /** @description patch a note identified by the noteId with changes in the body */
        patch: operations["patchNoteById"];
        trace?: never;
    };
    "/notes/{noteId}/content": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                noteId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        /** @description Returns note content identified by its ID */
        get: operations["getNoteContent"];
        /** @description Updates note content identified by its ID */
        put: operations["putNoteContentById"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notes/{noteId}/export": {
        parameters: {
            query?: {
                format?: "html" | "markdown" | "share";
            };
            header?: never;
            path: {
                noteId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        /** @description Exports ZIP file export of a given note subtree. To export whole document, use "root" for noteId */
        get: operations["exportNoteSubtree"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notes/{noteId}/import": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                noteId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Imports ZIP file into a given note. */
        post: operations["importZip"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notes/{noteId}/revision": {
        parameters: {
            query?: {
                format?: "html" | "markdown";
            };
            header?: never;
            path: {
                noteId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Create a note revision for the given note */
        post: operations["createRevision"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/branches": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Create a branch (clone a note to a different location in the tree). In case there is a branch between parent note and child note already,  then this will update the existing branch with prefix, notePosition and isExpanded. */
        post: operations["postBranch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/branches/{branchId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                branchId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        /** @description Returns a branch identified by its ID */
        get: operations["getBranchById"];
        put?: never;
        post?: never;
        /** @description deletes a branch based on the branchId supplied. If this is the last branch of the (child) note,  then the note is deleted as well. */
        delete: operations["deleteBranchById"];
        options?: never;
        head?: never;
        /** @description patch a branch identified by the branchId with changes in the body. Only prefix and notePosition can be updated. If you want to update other properties, you need to delete the old branch and create a new one. */
        patch: operations["patchBranchById"];
        trace?: never;
    };
    "/attachments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description create an attachment */
        post: operations["postAttachment"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/attachments/{attachmentId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                attachmentId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        /** @description Returns an attachment identified by its ID */
        get: operations["getAttachmentById"];
        put?: never;
        post?: never;
        /** @description deletes an attachment based on the attachmentId supplied. */
        delete: operations["deleteAttachmentById"];
        options?: never;
        head?: never;
        /** @description patch an attachment identified by the attachmentId with changes in the body. Only role, mime, title, and position are patchable. */
        patch: operations["patchAttachmentById"];
        trace?: never;
    };
    "/attachments/{attachmentId}/content": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                attachmentId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        /** @description Returns attachment content identified by its ID */
        get: operations["getAttachmentContent"];
        /** @description Updates attachment content identified by its ID */
        put: operations["putAttachmentContentById"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/attributes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description create an attribute for a given note */
        post: operations["postAttribute"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/attributes/{attributeId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                attributeId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        /** @description Returns an attribute identified by its ID */
        get: operations["getAttributeById"];
        put?: never;
        post?: never;
        /** @description deletes an attribute based on the attributeId supplied. */
        delete: operations["deleteAttributeById"];
        options?: never;
        head?: never;
        /** @description patch an attribute identified by the attributeId with changes in the body. For labels, only value and position can be updated. For relations, only position can be updated. If you want to modify other properties, you need to delete the old attribute and create a new one. */
        patch: operations["patchAttributeById"];
        trace?: never;
    };
    "/refresh-note-ordering/{parentNoteId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                parentNoteId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description notePositions in branches are not automatically pushed to connected clients and need a specific instruction.  If you want your changes to be in effect immediately, call this service after setting branches' notePosition.  Note that you need to supply "parentNoteId" of branch(es) with changed positions. */
        post: operations["postRefreshNoteOrdering"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/inbox/{date}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description returns an "inbox" note, into which note can be created. Date will be used depending on whether the inbox is a fixed note (identified with #inbox label) or a day note in a journal. */
        get: operations["getInboxNote"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/calendar/days/{date}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description returns a day note for a given date. Gets created if doesn't exist. */
        get: operations["getDayNote"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/calendar/weeks/{date}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description returns a week note for a given date. Gets created if doesn't exist. */
        get: operations["getWeekFirstDayNote"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/calendar/months/{month}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description returns a week note for a given date. Gets created if doesn't exist. */
        get: operations["getMonthNote"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/calendar/years/{year}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description returns a week note for a given date. Gets created if doesn't exist. */
        get: operations["getYearNote"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/login": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description get an ETAPI token based on password for further use with ETAPI */
        post: operations["login"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description logout (delete/deactivate) an ETAPI token */
        post: operations["logout"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/app-info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description returns information about the running Trilium instance */
        get: operations["getAppInfo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/backup/{backupName}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description If the backupName is e.g. "now", then the backup will be written to "backup-now.db" file */
                backupName: components["schemas"]["StringId"];
            };
            cookie?: never;
        };
        get?: never;
        /** @description Create a database backup under a given name */
        put: operations["createBackup"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        CreateNoteDef: {
            /** @description Note ID of the parent note in the tree */
            parentNoteId: components["schemas"]["EntityId"];
            title: string;
            /** @enum {string} */
            type: "text" | "code" | "file" | "image" | "search" | "book" | "relationMap" | "render";
            /**
             * @description this needs to be specified only for note types 'code', 'file', 'image'.
             * @example application/json
             */
            mime?: string;
            content: string;
            /** @description Position of the note in the parent. Normal ordering is 10, 20, 30 ...  So if you want to create a note on the first position, use e.g. 5, for second position 15, for last e.g. 1000000 */
            notePosition?: number;
            /** @description Prefix is branch (placement) specific title prefix for the note.  Let's say you have your note placed into two different places in the tree,  but you want to change the title a bit in one of the placements. For this you can use prefix. */
            prefix?: string;
            /** @description true if this note (as a folder) should appear expanded */
            isExpanded?: boolean;
            /** @description DON'T specify unless you want to force a specific noteId */
            noteId?: components["schemas"]["EntityId"];
            /** @description DON'T specify unless you want to force a specific branchId */
            branchId?: components["schemas"]["EntityId"];
            /** @description Local timestap of the note creation. Specify only if you want to override the default (current datetime in the current timezone/offset). */
            dateCreated?: components["schemas"]["LocalDateTime"];
            /** @description UTC timestap of the note creation. Specify only if you want to override the default (current datetime). */
            utcDateCreated?: components["schemas"]["UtcDateTime"];
        };
        Note: {
            readonly noteId?: components["schemas"]["EntityId"];
            title?: string;
            /** @enum {string} */
            type?: "text" | "code" | "render" | "file" | "image" | "search" | "relationMap" | "book" | "noteMap" | "mermaid" | "webView" | "shortcut" | "doc" | "contentWidget" | "launcher";
            mime?: string;
            readonly isProtected?: boolean;
            /** @description ID of the blob object which effectively serves as a content hash */
            blobId?: string;
            readonly attributes?: components["schemas"]["AttributeList"];
            readonly parentNoteIds?: components["schemas"]["EntityIdList"];
            readonly childNoteIds?: components["schemas"]["EntityIdList"];
            readonly parentBranchIds?: components["schemas"]["EntityIdList"];
            readonly childBranchIds?: components["schemas"]["EntityIdList"];
            dateCreated?: components["schemas"]["LocalDateTime"];
            readonly dateModified?: components["schemas"]["LocalDateTime"];
            utcDateCreated?: components["schemas"]["UtcDateTime"];
            readonly utcDateModified?: components["schemas"]["UtcDateTime"];
        };
        /** @description Branch places the note into the tree, it represents the relationship between a parent note and child note */
        Branch: {
            branchId?: components["schemas"]["EntityId"];
            /** @description identifies the child note */
            readonly noteId?: components["schemas"]["EntityId"];
            /** @description identifies the parent note */
            readonly parentNoteId?: components["schemas"]["EntityId"];
            prefix?: string;
            /** Format: int32 */
            notePosition?: number;
            isExpanded?: boolean;
            readonly utcDateModified?: components["schemas"]["UtcDateTime"];
        };
        NoteWithBranch: {
            note?: components["schemas"]["Note"];
            branch?: components["schemas"]["Branch"];
        };
        /** @description Attachment is owned by a note, has title and content */
        Attachment: {
            readonly attachmentId?: components["schemas"]["EntityId"];
            /** @description identifies the owner of the attachment, is either noteId or revisionId */
            ownerId?: components["schemas"]["EntityId"];
            role?: string;
            mime?: string;
            title?: string;
            /** Format: int32 */
            position?: number;
            /** @description ID of the blob object which effectively serves as a content hash */
            blobId?: string;
            readonly dateModified?: components["schemas"]["LocalDateTime"];
            readonly utcDateModified?: components["schemas"]["UtcDateTime"];
            readonly utcDateScheduledForErasureSince?: components["schemas"]["UtcDateTime"];
            /** Format: int32 */
            contentLength?: number;
        };
        CreateAttachment: {
            /** @description identifies the owner of the attachment, is either noteId or revisionId */
            ownerId?: components["schemas"]["EntityId"];
            role?: string;
            mime?: string;
            title?: string;
            content?: string;
            /** Format: int32 */
            position?: number;
        };
        /** @description Attribute (Label, Relation) is a key-value record attached to a note. */
        Attribute: {
            attributeId?: components["schemas"]["EntityId"];
            /** @description identifies the child note */
            readonly noteId?: components["schemas"]["EntityId"];
            /** @enum {string} */
            type?: "label" | "relation";
            /** @example shareCss */
            name?: string;
            value?: string;
            /** Format: int32 */
            position?: number;
            isInheritable?: boolean;
            readonly utcDateModified?: components["schemas"]["UtcDateTime"];
        };
        AttributeList: components["schemas"]["Attribute"][];
        SearchResponse: {
            results: components["schemas"]["Note"][];
            /** @description debugging info on parsing the search query enabled with &debug=true parameter */
            debugInfo?: Record<string, never>;
        };
        /** @example evnnmvHTCgIn */
        EntityId: string;
        /** @example my_ID */
        StringId: string;
        EntityIdList: components["schemas"]["EntityId"][];
        /** @example 2021-12-31 20:18:11.930+0100 */
        LocalDateTime: string;
        /** @example 2021-12-31 19:18:11.930Z */
        UtcDateTime: string;
        AppInfo: {
            /**
             * @description Trilium version
             * @example 0.50.2
             */
            appVersion?: string;
            /**
             * Format: int32
             * @description DB version
             * @example 194
             */
            dbVersion?: number;
            /**
             * Format: int32
             * @description Sync protocol version
             * @example 25
             */
            syncVersion?: number;
            /**
             * Format: date-time
             * @description build date
             * @example 2022-02-09T22:52:36+01:00
             */
            buildDate?: string;
            /**
             * @description git build revision
             * @example 23daaa2387a0655685377f0a541d154aeec2aae8
             */
            buildRevision?: string;
            /**
             * @description data directory where Trilium stores files
             * @example /home/user/data
             */
            dataDirectory?: string;
            /**
             * @description version of the supported Trilium Web Clipper protocol
             * @example 1
             */
            clipperProtocolVersion?: string;
            /**
             * @description current UTC date time
             * @example 2022-03-07T21:54:25.277Z
             */
            utcDateTime?: string;
        };
        Error: {
            /**
             * Format: int32
             * @description HTTP status, identical to the one given in HTTP response
             * @example 400
             */
            status: number;
            /**
             * @description stable string constant
             * @example NOTE_IS_PROTECTED
             */
            code: string;
            /**
             * @description Human readable error, potentially with more details,
             * @example Note 'evnnmvHTCgIn' is protected and cannot be modified through ETAPI
             */
            message: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    createNote: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateNoteDef"];
            };
        };
        responses: {
            /** @description note created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["NoteWithBranch"];
                };
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    searchNotes: {
        parameters: {
            query: {
                /** @description search query string as described in https://triliumnext.github.io/Docs/Wiki/search.html */
                search: string;
                /** @description enable fast search (fulltext doesn't look into content) */
                fastSearch?: boolean;
                /** @description search by default ignores archived notes. Set to 'true' to includes archived notes into search results. */
                includeArchivedNotes?: boolean;
                /** @description search only in a subtree identified by the subtree noteId. By default whole tree is searched. */
                ancestorNoteId?: components["schemas"]["EntityId"];
                /** @description define how deep in the tree should the notes be searched */
                ancestorDepth?: string;
                /**
                 * @description name of the property/label to order search results by
                 * @example [
                 *       "title",
                 *       "#publicationDate",
                 *       "isProtected",
                 *       "isArchived",
                 *       "dateCreated",
                 *       "dateModified",
                 *       "utcDateCreated",
                 *       "utcDateModified",
                 *       "parentCount",
                 *       "childrenCount",
                 *       "attributeCount",
                 *       "labelCount",
                 *       "ownedLabelCount",
                 *       "relationCount",
                 *       "ownedRelationCount",
                 *       "relationCountIncludingLinks",
                 *       "ownedRelationCountIncludingLinks",
                 *       "targetRelationCount",
                 *       "targetRelationCountIncludingLinks",
                 *       "contentSize",
                 *       "contentAndAttachmentsSize",
                 *       "contentAndAttachmentsAndRevisionsSize",
                 *       "revisionCount"
                 *     ]
                 */
                orderBy?: string;
                /** @description order direction, ascending or descending */
                orderDirection?: "asc" | "desc";
                /**
                 * @description limit the number of results you want to receive
                 * @example 10
                 */
                limit?: number;
                /** @description set to true to get debug information in the response (search query parsing) */
                debug?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description search response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["SearchResponse"];
                };
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    getNoteById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                noteId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description note response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Note"];
                };
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteNoteById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                noteId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description note deleted */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    patchNoteById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                noteId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Note"];
            };
        };
        responses: {
            /** @description note updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Note"];
                };
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    getNoteContent: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                noteId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description note content response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/html": string;
                };
            };
        };
    };
    putNoteContentById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                noteId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        /** @description html content of note */
        requestBody: {
            content: {
                "text/plain": string;
            };
        };
        responses: {
            /** @description note content updated */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    exportNoteSubtree: {
        parameters: {
            query?: {
                format?: "html" | "markdown" | "share";
            };
            header?: never;
            path: {
                noteId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description export ZIP file */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/zip": string;
                };
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    importZip: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                noteId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description note created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["NoteWithBranch"];
                };
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    createRevision: {
        parameters: {
            query?: {
                format?: "html" | "markdown";
            };
            header?: never;
            path: {
                noteId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description revision has been created */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    postBranch: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Branch"];
            };
        };
        responses: {
            /** @description branch updated (branch between parent note and child note already existed) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Branch"];
                };
            };
            /** @description branch created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Branch"];
                };
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    getBranchById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                branchId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description branch response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Branch"];
                };
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteBranchById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                branchId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description branch deleted */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    patchBranchById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                branchId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Branch"];
            };
        };
        responses: {
            /** @description branch updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Branch"];
                };
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    postAttachment: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateAttachment"];
            };
        };
        responses: {
            /** @description attachment created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Attachment"];
                };
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    getAttachmentById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                attachmentId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description attachment response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Attachment"];
                };
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteAttachmentById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                attachmentId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description attachment deleted */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    patchAttachmentById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                attachmentId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Attachment"];
            };
        };
        responses: {
            /** @description attribute updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Attachment"];
                };
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    getAttachmentContent: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                attachmentId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description attachment content response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/html": string;
                };
            };
        };
    };
    putAttachmentContentById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                attachmentId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        /** @description html content of attachment */
        requestBody: {
            content: {
                "text/plain": string;
            };
        };
        responses: {
            /** @description attachment content updated */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postAttribute: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Attribute"];
            };
        };
        responses: {
            /** @description attribute created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Attribute"];
                };
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    getAttributeById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                attributeId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description attribute response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Attribute"];
                };
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteAttributeById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                attributeId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description attribute deleted */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    patchAttributeById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                attributeId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Attribute"];
            };
        };
        responses: {
            /** @description attribute updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Attribute"];
                };
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    postRefreshNoteOrdering: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                parentNoteId: components["schemas"]["EntityId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description note ordering will be asynchronously updated in all connected clients */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    getInboxNote: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @example 2022-02-22 */
                date: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description inbox note */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Note"];
                };
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    getDayNote: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @example 2022-02-22 */
                date: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description day note */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Note"];
                };
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    getWeekFirstDayNote: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @example 2022-02-22 */
                date: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description week note */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Note"];
                };
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    getMonthNote: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @example 2022-02 */
                month: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description month note */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Note"];
                };
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    getYearNote: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @example 2022-02 */
                year: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description year note */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Note"];
                };
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    login: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description user's password used to e.g. login to Trilium server and/or protect notes */
                    password?: string;
                };
            };
        };
        responses: {
            /** @description auth token */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": {
                        /** @example Bc4bFn0Ffiok_4NpbVCDnFz7B2WU+pdhW8B5Ne3DiR5wXrEyqdjgRIsk= */
                        authToken?: string;
                    };
                };
            };
            /** @description Client IP has been blacklisted because too many requests (possibly failed authentications) were made within a short time frame, try again later */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    logout: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description logout successful */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    getAppInfo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description app info */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["AppInfo"];
                };
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
    createBackup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description If the backupName is e.g. "now", then the backup will be written to "backup-now.db" file */
                backupName: components["schemas"]["StringId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description backup has been created */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description unexpected error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json; charset=utf-8": components["schemas"]["Error"];
                };
            };
        };
    };
}
